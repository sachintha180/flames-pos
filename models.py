"""
models.py (docstring generated by DuetAI).

This module contains the models for the Flames POS application.
The models are defined using SQLAlchemy, which provides a
declarative way to define database tables.

The models are:
- User: Represents a user of the application.
- Customer: Represents a customer of the application.
- Staff: Represents a staff member of the application.
- Payment: Represents a payment made by a customer.
- Order: Represents an order placed by a customer.
- OrderProduct: Represents the products in an order.
- Product: Represents a product that can be ordered.
"""

import datetime
from typing import List
from sqlalchemy import (
    Column,
    Table,
    DateTime,
    Integer,
    String,
    Numeric,
    func,
    ForeignKey,
    UniqueConstraint,
    Enum,
)
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship
import enums


# base class for all declarative models
class Base(DeclarativeBase):
    pass


# initialized in app.py
db = SQLAlchemy(model_class=Base)


class User(db.Model):
    # attributes
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    username: Mapped[str] = mapped_column(String, nullable=False, unique=True)
    password: Mapped[str] = mapped_column(String, nullable=False)
    fullname: Mapped[str] = mapped_column(String, nullable=False)
    mobile_no: Mapped[str] = mapped_column(String(10), nullable=False, unique=True)
    email: Mapped[str] = mapped_column(String, nullable=True, unique=True)
    role: Mapped[enums.UserRole] = mapped_column(
        Enum(enums.UserRole),
        nullable=False,
        server_default=enums.UserRole.cashier.value,
    )
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, server_default=func.now()
    )
    last_logged: Mapped[datetime.datetime] = mapped_column(DateTime, nullable=True)

    # foreign key constraints for user-order (1:M) - ON DELETE NO CHANGE
    order: Mapped[List["Order"]] = relationship(back_populates="user")

    # representation method
    def __repr__(self):
        return f"User(id={self.id}, username={self.username}, fullname={self.fullname}, role={self.role})"


class Customer(db.Model):
    # attributes
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    fullname: Mapped[str] = mapped_column(String, nullable=False)
    mobile_no: Mapped[str] = mapped_column(String(10), nullable=False, unique=True)
    address: Mapped[str] = mapped_column(String, nullable=False)
    city: Mapped[str] = mapped_column(String, nullable=False)
    email: Mapped[str] = mapped_column(String, nullable=True, unique=True)
    registered_at: Mapped[str] = mapped_column(
        DateTime, nullable=False, server_default=func.now()
    )

    # foreign key constraints for customer-order (1:M) - ON DELETE CASCADE
    order: Mapped[List["Order"]] = relationship(
        back_populates="customer", cascade="all, delete", passive_deletes=True
    )

    # representation method
    def __repr__(self):
        return f"Customer(id={self.id}, fullname={self.fullname}, mobile_no={self.mobile_no})"


class Staff(db.Model):
    # attributes
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    fullname: Mapped[str] = mapped_column(String, nullable=False)
    role: Mapped[enums.StaffRole] = mapped_column(
        Enum(enums.StaffRole),
        nullable=False,
        server_default=enums.StaffRole.waiter.value,
    )
    mobile_no: Mapped[str] = mapped_column(String(10), nullable=False, unique=True)
    email: Mapped[str] = mapped_column(String, unique=True, nullable=True)

    # foreign key constraint for staff-order (1:1) - ON DELETE NO CHANGE
    order: Mapped["Order"] = relationship(back_populates="staff")

    # representation method
    def __repr__(self):
        return f"Staff(id={self.id}, fullname={self.fullname}, role={self.role}, mobile_no={self.mobile_no})"


class Payment(db.Model):
    # attributes
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    amount: Mapped[float] = mapped_column(Numeric, nullable=False)
    ptype: Mapped[enums.PaymentType] = mapped_column(
        Enum(enums.PaymentType),
        nullable=False,
        server_default=enums.PaymentType.cash.value,
    )
    paid: Mapped[float] = mapped_column(Numeric, nullable=False)
    balance: Mapped[float] = mapped_column(Numeric, nullable=False)
    paid_at: Mapped[datetime.datetime] = mapped_column(DateTime, nullable=False)
    discount: Mapped[float] = mapped_column(Numeric, nullable=True)

    # foreign key constraint for payment-order (1:1) - ON DELETE NO CHANGE
    order: Mapped["Order"] = relationship(back_populates="payment")

    # representation method
    def __repr__(self):
        return f"Payment(id={self.id}, amount={self.amount}, ptype={self.ptype})"


# SQLAlchemy.Core associative table for resolving order-product (M:M) relationship
OrderProduct = Table(
    # attributes
    "order_product",
    db.metadata,
    Column("order_id", ForeignKey("order.id"), primary_key=True),
    Column("product_id", ForeignKey("product.id"), primary_key=True),
    Column("quantity", Integer, nullable=False),
)


class Order(db.Model):
    # attributes
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    otype: Mapped[str] = mapped_column(String, nullable=False)
    description: Mapped[str] = mapped_column(String, nullable=True)
    status: Mapped[enums.OrderStatus] = mapped_column(
        Enum(enums.OrderStatus),
        nullable=False,
        server_default=enums.OrderStatus.pending.value,
    )
    ordered_at: Mapped[datetime.datetime] = mapped_column(
        DateTime, nullable=False, server_default=func.now()
    )
    completed_at: Mapped[datetime.datetime] = mapped_column(DateTime, nullable=True)
    table_no: Mapped[int] = mapped_column(Integer, nullable=True)

    # foreign key constraints for order-customer (M:1) - ON DELETE CASCADE
    customer_id: Mapped[int] = mapped_column(
        ForeignKey("customer.id", ondelete="CASCADE")
    )
    customer: Mapped["Customer"] = relationship(back_populates="order")

    # foreign key constraints for order-user (M:1) - ON DELETE NO CHANGE
    user_id: Mapped[int] = mapped_column(ForeignKey("user.id"))
    user: Mapped["User"] = relationship(back_populates="order")

    # foreign key constraint for order-payment (1:1) - ON DELETE NO CHANGE
    payment_id: Mapped[int] = mapped_column(ForeignKey("payment.id"))
    payment: Mapped["Payment"] = relationship(back_populates="order")

    # foreign key constraint for order-staff (1:1) - ON DELETE NO CHANGE
    staff_id: Mapped[int] = mapped_column(ForeignKey("staff.id"))
    staff: Mapped["Staff"] = relationship(back_populates="order")

    # foreign key constraint for order-product (1:M) - ON DELETE NO CHANGE
    product: Mapped[List["Product"]] = relationship(
        secondary=OrderProduct, back_populates="order"
    )

    # setup unique constraints for 1:1 relationships
    __table_args__ = (UniqueConstraint("payment_id"), UniqueConstraint("staff_id"))

    # representation method
    def __repr__(self):
        return f"Order(id={self.id}, otype={self.otype}, status={self.status})>"


class Product(db.Model):
    # attributes
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    name: Mapped[str] = mapped_column(String, nullable=False)
    description: Mapped[str] = mapped_column(String, nullable=True)
    price: Mapped[float] = mapped_column(Numeric, nullable=False)

    # foreign key constraint for order-product (1:M) - ON DELETE NO CHANGE
    order: Mapped[List["Order"]] = relationship(
        secondary=OrderProduct, back_populates="product"
    )

    # representation method
    def __repr__(self):
        return f"Product(id={self.id}, name={self.name}, price={self.price})>"
